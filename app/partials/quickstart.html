<div class="column3 span1">
<p class="alert alert-info">This guide describes the fast path to integrating the MokiManage SDK into your <span
        context-show="apple">iOS</span><span context-show="android">Android</span> app. You should already have an
    account on MokiManage.com, and have an app key and tenant ID.</p>


<div context-show="apple">

    <h1 class="quickstart typeBlue">iOS Integration</h1>
    To set up your iOS app to use the MokiManage SDK, you need to take the following steps:

    <a id="apns"></a>
    <ol>
        <li>Setup Apple Push Notification service (APNs) for your app.</li>
        <li>Add the MokiManage SDK to your project.</li>
        <li>Setup your app delegate.</li>
        <li>Silent enrollment</li>
        <li>Check the MokiManage console for the device running your app.</li>
    </ol>
    <br/><h4 class="quickstart typeBlue">Setting up APNs</h4>

    The MokiManage platform utilizes Apple Push Notification Service (APNs) to communicate with your application. In
    order to send messages to devices on your behalf, you will need to provide the appropriate certificates that you get
    from Apple. This guide is not meant to walk you through the steps to obtain those APNs certs. That is well
    documented in many places, but here are a couple of useful tutorials that can give you a quick overview in case you
    have not been through the process previously:<br/>

    <br/><a href="http://www.raywenderlich.com/32960/apple-push-notification-services-in-ios-6-tutorial-part-1">Apple
    Push Notification Services in iOS 6</a><br/>

    <a href="http://iosapplove.com/archive/2012/10/apns-tutorial-how-to-send-pushnotifications-to-my-app/">Apple Push
        Notification Services Tutorial</a><br/>

    <br/>You can find more detail on setting up your app for APNs in the <a
        href="../apns-setup">APNs Setup Guide</a>.

    <br/><br/>

    <h4 class="quickstart typeBlue" id="iosSdk">Adding the MokiManage SDK to your Xcode project</h4>

    Setting up your Xcode project consists of the following steps:

    <ul>
        <li>Download and install the SDK and necessary dependencies</li>
        <li>Update your <code>Info.plist</code> file.</li>
    </ul>

    The MokiManage SDK can be downloaded from GitHub:<br/>

    <a href="https://github.com/MokiMobility/MokiManageSDK/tree/ios">https://github.com/MokiMobility/MokiManageSDK/tree/ios</a><br/><br/>

    If your project utilizes <a href="http://cocoapods.org" target="_blank">CocoaPods</a>, then add this dependency line
    to your <code class="http">Podfile</code><br/><br/>

    <code>pod 'MokiManageSDK', :git =&gt; 'https://github.com/MokiMobility/MokiManageSDK.git', :tag =&gt;
        '1.1.1'</code><br/><br/>

    If you want to utilize CocoaPods, but do not already have an existing <code class="http">Podfile</code>, please see
    the <a href="https://github.com/MokiMobility/MokiManageSDK/tree/ios">iOS SDK readme</a> for an example
    file.<br/><br/>

    <div class="well">
    We highly encourage the use of CocoaPods. It will ease your configuration, help you get updates to our SDK and help ensure that you have all the required dependencies. If you do choose to manually add the SDK to your project there is some more work to do. You will need to add the following to your project:<br/><br/>

    <b>Dependencies</b>:<br/>
    <ul>
        <li>AFNetworking - <a href="https://github.com/AFNetworking/AFNetworking">https://github.com/AFNetworking/AFNetworking</a>
        </li>
    </ul>
    <b>Frameworks</b>:<br/>
    <ul>
        <li>ExternalAccessory</li>
        <li>CoreTelephony</li>
        <li>CoreLocation</li>
        <li>SystemConfiguration</li>
        <li>Foundation</li>
        <li>CoreGraphics</li>
        <li>MobileCoreServices</li>
        <li>SenTestingKit</li>
        <li>Security</li>
    </ul>
    <br/>
    
    Due to our use of the network reachability APIs you will also need to add two <code>#import</code>s to your precompilied headers file, <code>Prefix.pch</code>.
    <pre><code>#import &lt;SystemConfiguration/SystemConfiguration.h&gt;
#import &lt;MobileCoreServices/MobileCoreServices.h&gt;</code></pre>
        see <a href="https://github.com/AFNetworking/AFNetworking/wiki/AFNetworking-FAQ">AFNetworking FAQ</a> for additional details
        </div>
    
    <br/>

    Add an dictionary entry to your target's <code>Info.plist</code> named <code>certType</code>, with 3 boolean items.
    The items are: <code>store</code>, <code>enterprise</code>, and <code>sandbox</code>. This entry tells the SDK which
    APNS cert the platform should use to communicate with the app. These entries map to the same cert entries you
    uploaded in MokiManage. During development, mark YES for sandbox, and no for the other entries.<br/><br/>
    <img alt="" src="img/PlistCertType.png" width="75%">
    <br/>

    <br/><br/>
    <h4 class="quickstart typeBlue" id="iosDelegate">Setting up Your App Delegate</h4>
    You need to update your app delegate to work with MokiManage and APNs.<br/><br/>
    First, add the <code>MokiManage.h</code> header to your app delegate header file:
    <pre><code>#import "MokiManage.h"</code></pre>
    and add the MokiManage protocol to your delegate:
    <pre><code>@interface AppDelegate : UIResponder &lt;UIApplicationDelegate, MokiManageDelegate&gt;</code></pre>
    Second, in your <code>AppDelegate.m</code> file, add a declaration for your API key and tenant ID:
<pre><code>#define API_KEY @"whatever-your-app-key-is-useitherenow"
    #define Tenant_ID @"whatever-your-tenaant-id-is-useitnow"
</code></pre>
    Third, initiate the session with the MokiManage SDK from your app delegate’s
    <code>didFinishLaunchingWithOptions:</code> method, calling the <code>initializeWithApiKey:</code> method.
<pre><code>
    NSError *error;

    [[MokiManage sharedManager] initializeWithApiKey:API_KEY
    launchingOptions:launchOptions
    enableASM:NO
    enableAEM:YES
    enableComplianceChecking:NO
    asmSettingsFileName:nil
    error:&amp;error];

    [[MokiManage sharedManager] setDelegate:self];
</code></pre>
    Fourth, you need to add the delegate methods for APNs. From the <code>didRegisterForRemoteNotificationsWithDeviceToken:</code>
    method, call MokiManage to pass on the device token. Now MokiManage has the device's APNs token and will use that to
    send APNs messages.<br/>

    <p class="alert alert-info"><b>IMPORTANT NOTE</b> - The iOS Simulator does not correctly register for an APNs token,
        which is required in order to register a device with MokiManage. In order to test the entire device registration
        lifecycle, you have to use a physical device.</p>

    Fifth, add the appropriate logic to the <code>didFailToRegisterForRemoteNotificationsWithError:</code> and <code>didReceiveRemoteNotification:</code>
    methods.
<pre><code>
    - (void)application:(UIApplication*)application
    didRegisterForRemoteNotificationsWithDeviceToken:(NSData*)deviceToken {
    [[MokiManage sharedManager] setApnsToken:deviceToken];
    }

    - (void)application:(UIApplication*)application didFailToRegisterForRemoteNotificationsWithError:(NSError*)error {
    if(error) {
    // Add error processing here.
    NSLog(@"error registering for push notifications %@",error);
    }
    }

    - (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo {
    [[MokiManage sharedManager] didReceiveRemoteNotification:userInfo];
    }
</code></pre>
    <br/>

    Finally, in addition to adding the APNs methods, add the <code>MokiManageDelegate</code> methods to your delegate.
    To get up and running, you don’t need to have any logic in these delegate methods.
<pre>
<code>#pragma mark -
    #pragma mark MokiManageDelegate Methods

    -(void)finishedRegistrationWithError:(NSError *)error{
    if(error){
    // Proces the error
    }
    // Let other objects in your app know that registration is complete.
    }

    -(void)finishedUnRegistrationWithError:(NSError *)error{
    NSLog(@"MokiManage finishedUnRegistrationWithError %@", error.localizedDescription);

    }

    -(void)finishedRegisteringToANewTenantWithError:(NSError *)error{
    NSLog(@"MokiManage finishedRegisteringToANewTenantWithError");

    }

    -(void)finishedPullingSettings:(NSDictionary *)settings WithError:(NSError *)error {
    NSLog(@"MokiManage finishedPullingSettings");

    }

    -(void)finishedPushingSettings:(NSDictionary *)settings WithError:(NSError *)error {
    NSLog(@"MokiManage finishedPushingSettings with error: %@", error);

    }

    -(void)finishedEditingSettings{

    }</code></pre>
    <br/>

    <br/>

    <h4 class="quickstart typeBlue" id="iosSilent">Silent Enrollment</h4>
    The final step of the integration process is to add the code that enrolls the device with MokiManage. This is done
    by adding a call to the <code>silentlyRegisterDevice</code> method. This can be placed at any point in your app's
    workflow. For example purposes, add it inside of the delegate method <code>didRegisterForRemoteNotificationsWithDeviceToken:</code>
<pre>
<code>- (void)application:(UIApplication*)application
    didRegisterForRemoteNotificationsWithDeviceToken:(NSData*)deviceToken {
    [[MokiManage sharedManager] setApnsToken:deviceToken];
    [[MokiManage sharedManager] silentlyRegisterDevice:Tenant_ID ];
    }
</code></pre>
    <br/>

</div>
<!-- end context-show='apple' -->


<div context-show="android">
<h1 class="quickstart typeBlue">Android Integration</h1>
To setup your Android app to use the MokiManage SDK, you need to take the following steps:

<a id="eclipse"></a>
<ol>
    <li>Add the MokiManage SDK to your project.</li>
    <li>Set up the <code></code>AndroidManifest.xml</code></li>
    <li>Extend the <code>Application</code> class and add the new class to the <code>AndroidManifext.xml</code></li>
    <li>Configure your app to receive MokiManage broadcasts</li>
    <li>Silent Enrollment</li>
    <li>Check the MokiManage console for the device running your app.</li>
</ol>
<br/>
<h4 class="quickstart typeBlue">Adding MokiManage SDK to your Eclipse project</h4>
The MokiManage SDK is hosted in a Maven compatible repository on GitHub and as such you should be able to easily
integrate the SDK into your existing Maven, Gradle, Ant+Ivy, or other build tools compatible with a maven2 layout
repository. For more information please see the Android branch <a
        href="https://github.com/MokiMobility/MokiManageSDK/tree/android" target="_blank">README file</a>.<br/><br/>

If you want to manually add the SDK to your project, it can be downloaded directly from GitHub here:
<ui style="...">
    MokiManageSDK - <a
        href="https://raw.github.com/MokiMobility/MokiManageSDK/android/com/mokimobility/MokiManageSDK/1.0.0/MokiManageSDK-1.0.0.jar">MokiManageSDK-1.0.0.jar</a>
</ui>
<br/>
The MokiManage SDK uses Google’s <code>Gson</code> library to parse JSON. Because many developers already use Gson in
their apps, we have not included it in our library. You need to download the Gson 2.x file and include it in your
project.
<ul style="list-style: none; padding-left: 0; margin-left: 0;">
    <li>Gson - <a href="https://code.google.com/p/google-gson/downloads/list">https://code.google.com/p/google-gson/downloads/list</a>
    </li>
</ul>
<br/>


<h4 class="quickstart typeBlue">Setting Up the AndroidManifest.xml</h4>

You will need to include a number of permissions, receivers, and services in your application's <code>AndroidManifest.xml</code>
file. Please replace “<b>your.package.name.here</b>” with your application's package name.
<pre>
<code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
    &lt;!-- PERMISSIONS --&gt;

    &lt;uses-permission android:name="android.permission.READ_PHONE_STATE" /&gt;
    &lt;uses-permission android:name="android.permission.INTERNET" /&gt;
    &lt;uses-permission android:name="android.permission.READ_CONTACTS" /&gt;
    &lt;uses-permission android:name="android.permission.ACCESS_COURSE_LOCATION" /&gt;
    &lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" /&gt;
    &lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" /&gt;
    &lt;uses-permission android:name="android.permission.ACCESS_SUPERUSER" /&gt;
    &lt;uses-permission android:name="android.permission.WAKE_LOCK" /&gt;
    &lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt;
    &lt;uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" /&gt;
    &lt;uses-permission android:name="android.permission.ACCESS_WIFI_STATE" /&gt;
    &lt;uses-permission android:name="android.permission.BLUETOOTH" /&gt;
    &lt;permission android:name="your.package.name.here.permission.C2D_MESSAGE"
    android:protectionLevel="signature" /&gt;
    &lt;uses-permission android:name="your.package.name.here.permission.C2D_MESSAGE" /&gt;
    &lt;uses-permission android:name="com.google.android.c2dm.permission.RECEIVE" /&gt;
    &lt;!-- RECEIVERS --&gt;

    &lt;receiver android:name="com.moki.aem.receivers.BootReceiver" &gt;

    &lt;intent-filter&gt;

    &lt;action android:name="android.intent.action.BOOT_COMPLETED" /&gt;
    &lt;/intent-filter&gt;

    &lt;/receiver&gt;
    &lt;receiver
    android:name="com.moki.aem.receivers.LogAlarmReceiver"
    android:exported="false" /&gt;
    &lt;receiver
    android:name="com.moki.aem.receivers.StatusAlarmReceiver"
    android:exported="false" /&gt;
    &lt;receiver
    android:name="com.moki.aem.receivers.StoreLogsAlarmReceiver"
    android:exported="false" /&gt;
    &lt;receiver
    android:name="com.moki.aem.receivers.HeartBeatAlarmReceiver"
    android:exported="false" /&gt;
    &lt;receiver
    android:name="com.moki.appregistration.receiver.NotificationReceiver"
    android:exported="false" &gt;

    &lt;intent-filter&gt;

    &lt;action android:name="com.moki.manage.MokiManangeAction" /&gt;
    &lt;/intent-filter&gt;

    &lt;/receiver&gt;
    &lt;receiver
    android:name="com.google.android.c2dm.C2DMBroadcastReceiver"
    android:permission="com.google.android.c2dm.permission.SEND" &gt;

    &lt;intent-filter&gt;

    &lt;action android:name="com.google.android.c2dm.intent.RECEIVE" /&gt;

    &lt;category android:name="your.package.name.here" /&gt;
    &lt;/intent-filter&gt;

    &lt;intent-filter&gt;

    &lt;action android:name="com.google.android.c2dm.intent.REGISTRATION" /&gt;

    &lt;category android:name="your.package.name.here" /&gt;
    &lt;/intent-filter&gt;

    &lt;/receiver&gt;
    &lt;receiver
    android:name="com.moki.aem.receivers.AEMCommandReceiver"
    android:exported="false" &gt;

    &lt;intent-filter&gt;

    &lt;action android:name="com.moki.aem.aemCommandIntent" /&gt;
    &lt;/intent-filter&gt;

    &lt;/receiver&gt;
    &lt;service android:name="com.moki.appregistration.C2DMReceiver" /&gt;
    &lt;service
    android:name="com.moki.aem.utils.LoggingService" /&gt;

    &lt;service
    android:name="com.moki.aem.utils.ScreenShotUtil"
    android:exported="false" &gt;

    &lt;intent-filter&gt;

    &lt;action android:name="com.moki.screenshot" /&gt;

    &lt;category android:name="com.moki.android.kiosk" /&gt;
    &lt;/intent-filter&gt;

    &lt;/service&gt;</code></pre>
<br/><br/>
<h4 class="quickstart typeBlue">Extending the Application Class</h4>
While you can do the following in an activity, we recommend that you create a custom <code>Application</code> class.
This class will help you maintain a global application state.<br/>
<b>Setting up MokiManage in Your Custom Application</b>
First, import the <code>MokiManage</code> in your <code>CustomApplication.java</code> file:

<pre><code>import com.moki.manage.api.MokiManage;</code></pre>
<br/>

Second, create constants for your api key and tenant ID:
<pre><code>private static final String API_KEY = "whatever-your-apik-eyis-useitherenow";
    private static final String TENANT_ID = "whatever-your-tennat-id-is-useitherenow";
</code></pre>
<br/>

Third, initiate the session with the MokiManage SDK from the onCreate function of your
<code>CustomApplication.java</code> file:
<pre><code>public class CustomApplication extends Application implements Application.ActivityLifecycleCallbacks {
    private static MokiManageApplication instance;
    private MokiManage mmanage;
    private int activeActivityCount = 0;
    private final boolean enableASM = false;
    private final boolean enableAEM = true;
    private final boolean enableCompliance = false;
    private final String appKey = "&lt;YOUR APP KEY HERE&gt;";
    private final String appID = "&lt;YOUR APP ID HERE&gt;";

    @Override
    public void onCreate() {
        super.onCreate();
        Context context = this;
        mmanage = MokiManage.sharedInstance(appKey, appID, context, enableASM, enableAEM, enableCompliance);
        registerActivityLifecycleCallbacks(this);
        instance = this;
    }

    public static MokiManageApplication instance(){
        return instance;
    }

    public  MokiManage mokiManage(){
        return mmanage;
    }

    @Override
    public void onActivityStarted(Activity activity) {
        activeActivityCount++;
        if(activeActivityCount == 1){
            mmanage.resume();
        }
    }

    @Override
    public void onActivityStopped(Activity activity) {
        activeActivityCount--;
        if(activeActivityCount == 0){
            mmanage.pause();
        }
    }

    @Override
    public void onActivityCreated(Activity activity, Bundle savedInstanceState) {
    }

    @Override
    public void onActivityDestroyed(Activity activity) {
    }

    @Override
    public void onActivityPaused(Activity activity) {
    }

    @Override
    public void onActivityResumed(Activity activity) {
    }

    @Override
    public void onActivitySaveInstanceState(Activity activity, Bundle outState) {
    }
  }
</code></pre>
<br/>
Finally, include the new class name in your <code>AndroidManifest.xml</code> file.
<pre><code>&lt;application
    android:name=".ApplicationContext"
    android:icon="@drawable/icon"
    android:label="@string/app_name"
    android:theme="@android:style/Theme.NoTitleBar.Fullscreen"&gt;
</code></pre>
<br/>
<h4 class="quickstart typeBlue">Configure your app to receive MokiManage broadcasts</h4>
The MokiManage SDK will broadcast notifications in 5 different scenarios that your application will need to receive.
Those scenarios are <code>SETTINGS_PUSH_COMPLETED_NOTIFICATION</code>, <code>SETTINGS_PULL_COMPLETED_NOTIFICATION</code>,
<code>REGISTRATION_COMPLETED_NOTIFICATION</code>, <code>UNREGISTRATION_COMPLETED_NOTIFICATION</code>, <code>REGISTER_TO_A_NEW_TENANT_COMPLETED_NOTIFICATION</code>
You can handle these notifications by creating a new <code>BroadcastReceiver</code>. Make sure you declare the following
constants for the broadcasts:
<pre><code>public static final String SETTINGS_PUSH_COMPLETED_NOTIFICATION
    public static final String SETTINGS_PULL_COMPLETED_NOTIFICATION
    public static final String REGISTRATION_COMPLETED_NOTIFICATION
    public static final String UNREGISTRATION_COMPLETED_NOTIFICATION
    public static final String REGISTER_TO_A_NEW_TENANT_COMPLETED_NOTIFICATION
</code></pre>
<br/>

<pre><code>BroadcastReceiver mokiManageReciever = new BroadcastReceiver() {

    @Override
    public void onReceive(Context context, Intent intent) {
    if (intent.getAction().equals(MokiManage.REGISTRATION_COMPLETED_NOTIFICATION)) {
    //TODO: handle this as needed
    } else if (intent.getAction().equals(MokiManage.UNREGISTRATION_COMPLETED_NOTIFICATION)) {
    //TODO: handle this as needed
    } else if (intent.getAction().equals(MokiManage.REGISTER_TO_A_NEW_TENANT_COMPLETED_NOTIFICATION)) {
    //TODO: handle this as needed
    } else if (intent.getAction().equals(MokiManage.SETTINGS_PULL_COMPLETED_NOTIFICATION)) {
    //TODO: handle this as needed
    } else if (intent.getAction().equals(MokiManage.SETTINGS_PUSH_COMPLETED_NOTIFICATION)) {
    //TODO: handle this as needed
    }
    }
    };
    @Override
    public void onCreate() {
    super.onCreate();

    mmanage = MokiManage.sharedInstance(appKey, appID, context, enableASM, enableAEM, enableCompliance);
    registerActivityLifecycleCallbacks(this);
    instance = this;
    registerReceiver(mokiManageReciever, new IntentFilter(MokiManage.REGISTRATION_COMPLETED_NOTIFICATION));
    registerReceiver(mokiManageReciever, new IntentFilter(MokiManage.UNREGISTRATION_COMPLETED_NOTIFICATION));
    registerReceiver(mokiManageReciever, new IntentFilter(MokiManage.REGISTER_TO_A_NEW_TENANT_COMPLETED_NOTIFICATION));
    registerReceiver(mokiManageReciever, new IntentFilter(MokiManage.SETTINGS_PULL_COMPLETED_NOTIFICATION));
    registerReceiver(mokiManageReciever, new IntentFilter(MokiManage.SETTINGS_PUSH_COMPLETED_NOTIFICATION));
    }</code></pre>
<br/>

<h4 class="quickstart typeBlue">Silent Enrollment</h4>
The final step of the integration process is to add the code that enrolls the device with MokiManage. This is done by
adding a call to the <code>silentlyRegisterDevice</code> method.
<pre><code>@Override
    public void onCreate() {
    super.onCreate();

    mmanage = MokiManage.sharedInstance(appKey, appID, context, enableASM, enableAEM, enableCompliance);
    registerActivityLifecycleCallbacks(this);
    instance = this;

    if(!mokiManage.isRegistered()){
        mokiManage.silentlyRegisterDevice(TENANT_ID);
    }
  }</code></pre>


</div>
<!-- end context-show='android' -->


<br/><h4 class="quickstart typeBlue">Checking the MokiManage Console</h4>
To make sure your integration is working, load the app on your device, then go to the MokiManage console to see if you
can find the app there. After logging on to MokiManage.com, click the "Change App" drop-down at the top left. You should
see your application in the drop-down list. Select your app, and your device should be displayed in the list.<br/><br/>
If you see your device in the list, select it. On the right you should see a tabbed panel showing information about the
device you selected. The Dashboard tab shows a graphical representation of the logs the AEM module collects. If you
select the Details tab, you’ll see information about your device, such as battery status, network information, and so
on.<br/></br>
All of the device actions represented in the Actions drop-down menu are available without any additional
configuration.<br/><br/>
</div>
